Prefácio
========

Os problemas de desempenho do SQL são tão antigos como o próprio SQL - alguns podem até dizer que o SQL é inerentemente lento. Embora isso possa ter sido verdade nos primeiros dias do SQL, definitivamente não é verdade. No entanto, os problemas de desempenho SQL ainda são comuns. Como isso acontece? 

A linguagem SQL é talvez a mais bem sucedida linguagem de programação de quarta geração (4GL). Seu principal benefício é a capacidade de separar "o que" e "como" . Uma instrução SQL é uma descrição direta do que é necessário sem instruções sobre como obtê-lo. Considere o seguinte exemplo: 
SELECT date_of_birth FROM employees WHERE last_name = 'WINAND' 

A consulta SQL lê como uma sentença em linguagem natural que explica os dados solicitados. Escrever instruções SQL geralmente não requer qualquer conhecimento sobre o funcionamento interno do banco de dados ou do sistema de armazenamento (como discos, arquivos, etc.). Não é necessário informar ao banco de dados quais arquivos devem ser abertos ou como localizar as linhas solicitadas. Muitos desenvolvedores têm anos de experiência SQL, mas eles sabem muito pouco sobre o processamento que acontece no banco de dados.

A separação de conceitos - o que é necessário versus como obtê-lo - funciona notavelmente bem em SQL, mas ainda não é perfeito. A abstração atinge seus limites quando se trata de desempenho: o autor de uma instrução SQL por definição não se importa como o banco de dados executa a instrução. Conseqüentemente, o autor não é responsável pela execução lenta. No entanto, a experiência prova o contrário; Ou seja, o autor deve saber um pouco sobre o banco de dados para evitar problemas de desempenho. 

Acontece que a única coisa que os desenvolvedores precisam aprender é como indexar. A indexação de banco de dados é, de fato, uma tarefa de desenvolvimento. Isso ocorre porque a informação mais importante para a indexação adequada não é a configuração do sistema de armazenamento ou a configuração do hardware. As informações mais importantes para indexação é como o aplicativo consulta os dados. Esse conhecimento - sobre o caminho de acesso - não é muito acessível aos administradores de banco de dados (DBAs) ou consultores externos. Muito tempo é necessário para reunir essas informações através de engenharia reversa da aplicação: desenvolvimento, por outro lado, tem essa informação de qualquer maneira. 

Este documento cobre tudo o que os desenvolvedores precisam saber sobre índices - e nada mais. Para ser mais preciso, o livro abrange apenas o tipo de índice mais importante: o índice B-tree . O índice de árvore B funciona quase identicamente em muitos bancos de dados. 

A estrutura do livro é feita sob medida para desenvolvedores; A maioria dos capítulos correspondem a uma parte específica de uma instrução SQL. 

CAPÍTULO 1 - Anatomia de um Índice 
O primeiro capítulo é o único que não cobre especificamente o SQL; Trata-se da estrutura fundamental de um índice. Uma compreensão da estrutura do índice é essencial para seguir os capítulos posteriores - não pule isso! 
Embora o capítulo seja bastante curto - apenas cerca de oito páginas - depois de ler o capítulo você já entenderá o fenômeno dos índices lentos. 

CAPÍTULO 2 - A Cláusula Where 

Este capítulo explica todos os aspectos da cláusula where, desde pesquisas de coluna simples até cláusulas complexas para intervalos e casos como LIKE . 
Este capítulo compõe o corpo principal do documento. Depois de aprender a usar essas técnicas, você vai escrever SQL muito mais performático. 

CAPÍTULO 3 - Desempenho e escalabilidade 

Este capítulo é uma pequena digressão sobre as medidas de desempenho e a escalabilidade do banco de dados. Veja por que adicionar hardware não é a melhor solução para lentidão das consultas. 

CAPÍTULO 4 - A Operação de Junção

De volta ao SQL: aqui você encontrará uma explicação de como usar índices para executar um JOIN de maneira performática.

CAPÍTULO 5 - Dados de agrupamento
 
Alguma vez você já se perguntou se há alguma diferença entre selecionar uma única coluna ou todas as colunas? Aqui está a resposta - juntamente com um truque para obter um desempenho ainda melhor. 

CAPÍTULO 6 - Classificação e agrupamento 

Mesmo order by e group by pode usar índices. 

CAPÍTULO 7 - Resultados Parciais 

Este capítulo explica como beneficiar de uma execução "pipelined" se você não precisa do conjunto completo de resultados. 

CAPÍTULO 8 - Insert, Delete e Update

Como os índices afetam o desempenho de gravação? Os índices "não são de graça". Use-os sabiamente! 

APÊNDICE A - Planos de Execução 

Perguntando ao banco de dados como ele executa uma instrução. 

APÊNDICE B - Diretório Mito 

Lista alguns mitos e verdades comuns.

APÊNDICE C - Esquema de Exemplo 

Todos  as instruções de create e insert para as tabelas de exemplo do livro. 


Cap. 1. Anatomia de um índice SQL 
=================================

"Um índice faz a consulta ser rápida" é a explicação mais básica de um índice que eu já vi. Embora descreva o aspecto mais importante de um índice muito bem, é - infelizmente - não suficiente para este documento. Este capítulo descreve a estrutura do índice de uma forma menos superficial, mas não mergulha profundamente em detalhes. Ele fornece apenas insight suficiente para que se possa entender os aspectos de desempenho SQL discutidos ao longo do documento.
 
Um índice é uma estrutura distinta no banco de dados que é criado usando a instrução create index. Ele requer seu próprio espaço em disco e contém uma cópia dos dados da tabela indexada. Isso significa que um índice é pura redundância. A criação de um índice não altera os dados da tabela; Ele apenas cria uma nova estrutura de dados que se refere à tabela. Um índice de banco de dados é, afinal, muito parecido com o índice no final de um livro: ele ocupa seu próprio espaço, é altamente redundante e se refere à informação real armazenada em um lugar diferente.
 
Procurar em um índice de banco de dados é como pesquisar em uma lista telefônica impressa. O conceito-chave é que todas as entradas são organizadas em uma ordem bem definida. Encontrar dados em um conjunto de dados ordenados é rápido e fácil porque a ordem de classificação determina a posição de cada entrada. 

Um índice de banco de dados é, no entanto, mais complexo do que um diretório impresso porque sofre mudança constante. Atualizar um diretório impresso para cada alteração é impossível pela simples razão de que não há espaço entre as entradas existentes para adicionar novas. Um directório impresso contorna este problema apenas controlando as atualizações acumuladas com a próxima impressão. Um banco de dados SQL não pode esperar tanto tempo. Ele deve processar instruções de insert, delete e update imediatamente, mantendo a ordem do índice sem mover grandes quantidades de dados. 

O banco de dados combina duas estruturas de dados para enfrentar o desafio: uma lista duplamente vinculada e uma árvore de pesquisa. Essas duas estruturas explicam a maior parte das características de desempenho do banco de dados. 

Os nós-folha
------------

O objetivo principal de um índice é fornecer uma representação ordenada dos dados indexados. No entanto, não é possível armazenar os dados seqüencialmente porque uma instrução de insert precisaria mover as entradas a seguir para abrir espaço para a nova. Mover grandes quantidades de dados é muito custoso para a instrução insert portanto seria muito lento. A solução para o problema é estabelecer uma ordem lógica que seja independente da ordem física na memória. 

A ordem lógica é estabelecida através de uma lista duplamente ligada. Cada nó tem links para duas entradas vizinhas, muito parecido com uma cadeia. Novos nós são inseridos entre dois nós existentes, atualizando seus links para fazer referência ao novo nó. A localização física do novo nó não importa porque a lista duplamente vinculada mantém a ordem lógica. 

A estrutura de dados é chamada de lista duplamente vinculada porque cada nó se refere ao nó anterior e ao seguinte. Ele permite que o banco de dados leia o índice para a frente ou para trás, conforme necessário. Assim, é possível inserir novas entradas sem mover grandes quantidades de dados - basta alterar alguns ponteiros. 

Os bancos de dados usam listas duplamente vinculadas para conectar os chamados nós-folha do índice. Cada nó folha é armazenado em um bloco de banco de dados ou página; Ou seja, a menor unidade de armazenamento do banco de dados. Todos os blocos de índice são do mesmo tamanho - tipicamente alguns kilobytes. O banco de dados utiliza o espaço em cada bloco na medida do possível e armazena o maior número possível de entradas de índice em cada bloco. Isso significa que a ordem do índice é mantida em dois níveis diferentes: as entradas de índice dentro de cada nó folha e os nós folha entre si usando uma lista duplamente vinculada. 

[[[Figura 1.1 Nós-Folha do Índice e Dados da Tabela Correspondente]]]

A Figura 1.1 ilustra os nós-folha do índice e sua conexão com os dados da tabela. Cada entrada de índice consiste nas colunas indexadas (a chave, coluna 2) e refere-se à linha da tabela correspondente (via ROWID ou RID ou OID). Ao contrário do índice, os dados da tabela são armazenados em uma estrutura de fila (heap) e não são ordenados em geral. Não existe uma relação entre as linhas armazenadas no mesmo bloco de tabela nem existe qualquer ligação entre os blocos.

A árvore de pesquisa (árvore B) torna o índice rápido 
-----------------------------------------------------

Os nós-folha do índice são armazenados em uma ordem arbitrária - a posição no disco não corresponde à posição lógica de acordo com a ordem de índice. É como uma lista telefônica com páginas embaralhadas. Se você procurar por "Smith", mas primeiro abrir o diretório em "Robinson", não significa de forma alguma que Smith antecede Robinson. Um banco de dados precisa de uma segunda estrutura para encontrar rapidamente a entrada entre as páginas embaralhadas: uma árvore de pesquisa equilibrada - em suma: a árvore B.

[[[Figura 1.2 Estrutura da árvore B]]]

A Figura 1.2 mostra um índice de exemplo com 30 entradas. A lista duplamente vinculada estabelece a ordem lógica entre os nós-folha. Os nós-raiz e ramo suportam pesquisa rápida entre os nós-folha. 

A figura destaca um nó-ramo e os nós-folha a que se refere. Cada entrada de nó-ramo corresponde ao maior valor no respectivo nó-folha. Considere o primeiro nó da folha como um exemplo: o maior valor neste nó é 46, que é assim armazenado na entrada do nó-ramo correspondente. O mesmo é verdadeiro para os outros nós-folha de modo que no final o nó-ramo tem os valores 46, 53, 57 e 83. De acordo com este esquema, uma camada de ramo é construída até todos os nós-folha serem cobertos por um nó-ramo.
 
A próxima camada é construída de forma semelhante, mas em cima do primeiro nível de nó-ramo. O procedimento se repete até que todas as chaves se encaixam em um único nó: o nó-raiz. A estrutura é uma árvore de pesquisa equilibrada porque a profundidade da árvore é igual em todas as posições; A distância entre nó-raiz e nós-folha é a mesma em todos os lugares.

Nota 
Uma árvore B é uma árvore equilibrada - não uma árvore binária.

Uma vez criado, o banco de dados mantém o índice automaticamente. Ele aplica todas as insert , delete e atualizar para o índice e mantém a árvore em equilíbrio, causando assim sobrecarga de manutenção para operações de gravação. O Capítulo 8, " Modificando Dados " , explica isso com mais detalhes. 

[[[Figura 1.3 Traversal de árvore-B]]]

A Figura 1.3 mostra um fragmento de índice para ilustrar uma pesquisa para a chave "57". A árvore transversal começa no nó raiz do lado esquerdo. Cada entrada é processada em ordem ascendente até que um valor seja maior ou igual (>=) ao termo de pesquisa (57). Na figura é a entrada 83. O banco de dados segue a referência ao nó de ramificação correspondente e repete o procedimento até que o percurso de árvore alcance um nó-folha. 

Importante:

A árvore-B permite que o banco de dados encontre um nó-folha rapidamente. 
O percurso de árvore é uma operação muito eficiente - tão eficiente que me refiro a ela como a primeira potência de indexação. Ele funciona quase que instantaneamente, mesmo em um enorme conjunto de dados. Isso é principalmente devido ao equilíbrio da árvore, que permite acessar todos os elementos com o mesmo número de etapas e, em segundo lugar, devido ao crescimento logarítmico da profundidade da árvore. Isso significa que a profundidade da árvore cresce muito lentamente em comparação com o número de nós-folhas. Os índices do mundo real com milhões de registros têm uma profundidade de árvore de quatro ou cinco. Uma profundidade de árvore de seis é quase nunca visto.

Índices Lentos, Parte I 
-----------------------

Apesar da eficiência da iteração na árvore, ainda há casos em que uma pesquisa de índice não funciona tão rápido quanto o esperado. Essa contradição alimentou o mito do "índice degenerado" por um longo tempo. O mito proclama um índice de reconstrução como a solução milagrosa. Apêndice B " Myth Directory" abrange este e outros mitos em detalhe. Por enquanto, você pode dar por certo que a reconstrução de um índice não melhora o desempenho no longo prazo. A razão real onde consultas triviais podem ser lentas - mesmo quando se usa um índice - podem ser explicadas com base nas seções anteriores.

O primeiro ingrediente para uma pesquisa de índice lenta é a cadeia de nó-folha. Considere a pesquisa de "57" na Figura 1.3 novamente. Há obviamente duas entradas correspondentes no índice. Pelo menos duas entradas são as mesmas, para ser mais preciso: o próximo nó folha poderia ter entradas adicionais para "57". O banco de dados deve ler o próximo nó folha para ver se há mais entradas correspondentes. Isso significa que uma pesquisa de índice não só precisa executar o percurso de árvore, mas também precisa seguir a cadeia de nós de folhas.

O segundo ingrediente para uma pesquisa de índice lenta está no acesso a tabela. Mesmo um nó-folha único pode conter muitos hits, muitas vezes centenas. Os dados da tabela correspondente são geralmente dispersos em muitos blocos de tabelas (ver Figura 1.1 "Nós-folha de Índice e Dados da Tabela Correspondente"). Isso significa que há um acesso à tabela adicional para cada hit. 

Uma pesquisa de índice requer três etapas: (1) o percurso da árvore; (2) seguindo a cadeia de nós-folhas; (3) buscar os dados da tabela. O percurso da árvore é o único passo que tem um limite superior para o número de blocos acessados ​​- a profundidade do índice. As outras duas etapas podem precisar acessar muitos blocos - eles causam uma pesquisa lenta do índice. 

A origem do mito dos "índices lentos" é a descrença de que uma pesquisa de índice apenas atravessa a árvore, daí a idéia de que um índice lento deve ser causado por uma árvore "quebrada" ou "desequilibrada". A verdade é que você pode realmente verificar na maioria dos bancos de dados, como eles usam um índice. O banco de dados Oracle é bastante detalhado a este respeito e tem três operações distintas que descrevem uma pesquisa de índice básica:
 
INDEX UNIQUE SCAN 

O INDEX UNIQUE SCAN executa somente o percurso da árvore. O banco de dados Oracle usa essa operação se uma restrição exclusiva garante que os critérios de pesquisa não corresponderão a mais de uma entrada. 

INDEX RANGE SCAN

O INDEX RANGE SCAN realiza o percurso da árvore e segue a cadeia de nós-folha para encontrar todas as entradas correspondentes. Esta é a operação adicional se múltiplas entradas poderiam coincidir com os critérios de pesquisa.
 
ACESSO À TABELA POR ÍNDICE ROWID 

A operação TABLE ACCESS BY INDEX ROWID recupera a linha da tabela. Esta operação é (muitas vezes) executada para cada registro correspondente precedido por uma operação de INDEX SCAN.
 
O ponto importante é que um INDEX RANGE SCAN pode potencialmente ler uma grande parte de um índice. Se houver mais um acesso de tabela para cada linha, a consulta pode tornar-se lenta mesmo quando se utiliza um índice.

A Cláusula Where 
================


O capítulo anterior descreveu a estrutura dos índices e explicou a causa do mau desempenho do índice. Na próxima etapa, aprenderemos a detectar e evitar esses problemas em instruções SQL. Começamos por olhar para a cláusula where.
 
A cláusula where define a condição de pesquisa de uma instrução SQL e, portanto, cai no domínio funcional principal de um índice: encontrar dados rapidamente. Embora a cláusula where tenha um enorme impacto sobre o desempenho, é freqüentemente formulada descuidadamente de modo que o banco de dados tem que pesquisar uma grande parte do índice. O resultado: uma cláusula where mal escrita é o primeiro ingrediente de uma consulta lenta.

Este capítulo explica como diferentes operadores afetam o uso do índice e como garantir que um índice seja utilizável para o máximo de consultas possíveis. A última seção mostra anti-padrões comuns e apresenta alternativas que proporcionam melhor desempenho.

O Operador de Igualdade
-----------------------

O operador de igualdade é o mais trivial e o operador de SQL mais usado. Erros de indexação que afetam o desempenho ainda são muito comuns e cláusulas where que combinam várias condições são particularmente vulneráveis.

Esta seção mostra como verificar o uso do índice e explica como os índices concatenados podem otimizar as condições combinadas. Para auxiliar a compreensão, analisaremos uma consulta lenta para ver o impacto no mundo real das causas explicadas no Capítulo 1.

Chaves primárias 
----------------

Começamos com a cláusula where mais simples ainda mais comum: a pesquisa de chave primária. Para os exemplos ao longo deste capítulo, usamos a tabela EMPLOYEES definida da seguinte forma: 
 
CREATE TABLE employees (
	employee_id NUMBER NOT NULL, 
	first_name VARCHAR2(1000) NOT NULL, 
	last_name VARCHAR2(1000) NOT NULL, 
	date_of_birth DATE NOT NULL, 
	phone_number VARCHAR2(1000) NOT NULL, 
	CONSTRAINT employees_pk PRIMARY KEY (employee_id)
) 

O banco de dados cria automaticamente um índice para a chave primária. Isso significa que há um índice na coluna EMPLOYEE_ID, mesmo que não exista nenhuma instrução de create index. 

Dica 
O Apêndice C " Exemplo de Esquema " contém scripts para EMPLOYEES tabela EMPLOYEES com dados de amostra. Você pode usá-lo para testar os exemplos em seu próprio ambiente. 

Para seguir o texto, basta saber que a tabela contém 1000 linhas. 
A consulta a seguir usa a chave primária para recuperar o nome de um funcionário: 

SELECT first_name, last_name 
FROM employees 
WHERE employee_id = 123

A cláusula where não pode combinar várias linhas porque a restrição de chave primária garante exclusividade dos valores EMPLOYEE_ID. O banco de dados não precisa seguir os nós-folha de índice - é suficiente percorrer a árvore de índice. Podemos usar o chamado plano de execução para verificação: 

QUERY PLAN
-------------------------------------------
 Index Scan using employees_pk on employees 
   (cost=0.00..8.27 rows=1 width=14)
   Index Cond: (employee_id = 123::numeric)

O plano de execução mostra um INDEX SCAN - a operação que apenas atravessa a árvore de índice. Ele utiliza totalmente a escalabilidade logarítmica do índice para encontrar a entrada muito rapidamente - quase independente do tamanho da tabela. 

Dica:

O plano de execução mostra as etapas que o banco de dados leva para executar uma instrução SQL. O Apêndice A explica como recuperar e ler planos de execução com outros bancos de dados.

Depois de acessar o índice, o banco de dados deve fazer mais um passo para buscar os dados (FIRST_NAME, LAST_NAME) da tabela: a operação TABLE ACCESS BY INDEX ROWID. Esta operação pode se tornar um gargalo de desempenho - como explicado em "Índices Lentos, Parte I" -, mas não há tal risco em relação a um INDEX UNIQUE SCAN. Esta operação não retornará mais de uma entrada portanto não acontecerá mais de um acesso a tabela. Isso significa que os ingredientes de uma consulta lenta não estão presentes com um INDEX UNIQUE SCAN. 

Índices Concatenados 
--------------------

Mesmo que o banco de dados crie o índice para a chave primária automaticamente, ainda há espaço para refinamentos manuais se a chave consiste em várias colunas. Nesse caso, o banco de dados cria um índice em todas as colunas de chave primária - um chamado índice concatenado (também conhecido como multi-coluna, composto ou índice combinado). Observe que a ordem da coluna de um índice concatenado tem grande impacto na sua usabilidade, portanto, deve ser escolhida cuidadosamente.

Por uma questão de demonstração, vamos supor que há uma fusão da empresa. Os funcionários da outra empresa serão adicionados à nossa tabela EMPLOYEES então ela ficará dez vezes maior. Há apenas um problema: o EMPLOYEE_ID não é único entre ambas as empresas. Precisamos estender a chave primária através de um identificador extra - por exemplo, um ID de subsidiária. Assim, a nova chave primária tem duas colunas: o EMPLOYEE_ID como antes e o SUBSIDIARY_ID para restabelecer a unicidade.

O índice da nova chave primária é, portanto, definido da seguinte maneira:

CREATE UNIQUE INDEX employee_pk 
	ON employees (employee_id, subsidiary_id) 

Uma consulta para um determinado empregado tem que levar a chave primária completa em conta, ou seja, a coluna SUBSIDIARY_ID também tem que ser usada:

SELECT first_name, last_name 
FROM employees 
WHERE employee_id = 123 AND subsidiary_id = 30

QUERY PLAN
-------------------------------------------
 Index Scan using employees_pk on employees 
   (cost=0.00..8.27 rows=1 width=14)
   Index Cond: ((employee_id   = 123::numeric)
            AND (subsidiary_id = 30::numeric))
 
Sempre que uma consulta usa a chave primária completa, o banco de dados pode usar um INDEX UNIQUE SCAN - não importa quantas colunas o índice tem. Mas o que acontece quando se usa apenas uma das colunas-chave, por exemplo, ao pesquisar todos os funcionários de uma subsidiária?

SELECT first_name, last_name 
FROM employees 
WHERE subsidiary_id = 20 

QUERY PLAN
-------------------------------------------
 Seq Scan on employees 
   (cost=0.00..1398.50 rows=1070 width=14)
   Filter: (subsidiary_id = 2::numeric)

O plano de execução revela que o banco de dados não usa o índice. Em vez disso, executa um TABLE ACCESS FULL. Como resultado, o banco de dados lê toda a tabela e avalia cada linha com a cláusula where. O tempo de execução cresce com o tamanho da tabela: se a tabela crescer dez vezes, a TABLE ACCESS FULL leva dez vezes mais tempo. O perigo dessa operação é que ela geralmente é rápida o suficiente em um pequeno ambiente de desenvolvimento, mas causa sérios problemas de desempenho na produção.
 
O banco de dados não usa o índice porque ele não pode usar colunas individuais de um índice concatenado arbitrariamente. Uma análise mais detalhada da estrutura do índice torna isso claro.
 
Um índice concatenado é apenas um índice de árvore B como qualquer outro que mantém os dados indexados em uma lista ordenada. O banco de dados considera cada coluna de acordo com sua posição na definição do índice para classificar as entradas de índice. A primeira coluna é o critério de classificação primário ea segunda coluna determina a ordem somente se duas entradas tiverem o mesmo valor na primeira coluna e assim por diante. 
Importante 
Um índice concatenado é um índice em várias colunas . 
A ordenação de um índice de duas colunas é, portanto, como a ordenação de uma lista telefônica: é primeiro classificado por sobrenome, em seguida, pelo primeiro nome. Isso significa que um índice de duas colunas não suporta a pesquisa na segunda coluna sozinho; Que seria como procurar uma lista telefônica pelo primeiro nome. 
Figura 2.1 Índice Concatenado 

O trecho de índice na Figura 2.1 mostra que as entradas para a subsidiária 20 não são armazenadas próximas uma da outra. Também é evidente que não existem entradas com SUBSIDIARY_ID = 20 na árvore, embora existam nos nós de folha. A árvore é, portanto, inútil para esta consulta. 
Dica 
A visualização de um índice ajuda a compreender quais consultas o índice suporta. Você pode consultar o banco de dados para recuperar as entradas na ordem do índice (sintaxe SQL: 2008, consulte Para soluções proprietárias usando LIMIT , TOP ou ROWNUM ): 
 SELECT <INDEX COLUMN LIST> FROM <TABLE> ORDER BY <INDEX COLUMN LIST> FETCH FIRST 100 ROWS ONLY 
Se você colocar a definição do índice eo nome da tabela na consulta, você obterá um exemplo do índice. Pergunte a si mesmo se as linhas solicitadas estão agrupadas em um local central. Se não, a árvore de índice não pode ajudar a encontrar esse lugar. 
SUBSIDIARY_ID , claro, SUBSIDIARY_ID outro índice em SUBSIDIARY_ID para melhorar a SUBSIDIARY_ID de consulta. Existe, contudo, uma solução melhor - pelo menos se assumirmos que pesquisar EMPLOYEE_ID sozinho não faz sentido. 
Podemos aproveitar o fato de que a primeira coluna de índice é sempre utilizável para pesquisa. Novamente, é como uma lista telefônica: você não precisa saber o primeiro nome para procurar pelo sobrenome. O truque é inverter a ordem da coluna de índice para que o SUBSIDIARY_ID esteja na primeira posição: 
 CREATE UNIQUE INDEX EMPLOYEES_PK ON EMPLOYEES ( SUBSIDIARY_ID, EMPLOYEE_ID ) 
Ambas as colunas em conjunto ainda são exclusivas para consultas com a chave primária completa ainda pode usar um INDEX UNIQUE SCAN mas a seqüência de entradas de índice é totalmente diferente. O SUBSIDIARY_ID tornou-se o critério de classificação primário. Isso significa que todas as entradas para uma subsidiária estão no índice consecutivamente para que o banco de dados possa usar a árvore B para encontrar sua localização. 
Importante 
A consideração mais importante ao definir um índice concatenado é como escolher a ordem das colunas para que possa ser usada com a maior freqüência possível. 
O plano de execução confirma que o banco de dados usa o índice "invertido". O SUBSIDIARY_ID sozinho não é mais SUBSIDIARY_ID , então o banco de dados deve seguir os nós de folha para encontrar todas as entradas correspondentes: é, portanto, usando a operação INDIAN INDEX RANGE SCAN . 
DB2 
MySQL 
Oráculo 
 -------------------------------------------------------------- |Id |Operation | Name | Rows | Cost | -------------------------------------------------------------- | 0 |SELECT STATEMENT | | 106 | 75 | | 1 | TABLE ACCESS BY INDEX ROWID| EMPLOYEES | 106 | 75 | |*2 | INDEX RANGE SCAN | EMPLOYEE_PK | 106 | 2 | -------------------------------------------------------------- Predicate Information (identified by operation id): --------------------------------------------------- 2 - access("SUBSIDIARY_ID"=20) 
PostgreSQL 
servidor SQL 
Em geral, um banco de dados pode usar um índice concatenado ao pesquisar com as colunas principais (à esquerda). Um índice com três colunas pode ser usado ao pesquisar a primeira coluna, ao pesquisar com as duas primeiras colunas juntas e ao pesquisar usando todas as colunas. 
Mesmo que a solução de dois índices ofereça um desempenho muito bom também, a solução de índice único é preferível. Ele não só economiza espaço de armazenamento, mas também a sobrecarga de manutenção para o segundo índice. Quanto menos índices tiver uma tabela, melhor será o desempenho de insert , delete e atualização. 
Para definir um índice ótimo, você deve entender mais do que apenas como os índices funcionam - você também deve saber como o aplicativo consulta os dados. Isso significa que você precisa conhecer as combinações de colunas que aparecem na cláusula where. 
Definir um índice ótimo é, portanto, muito difícil para consultores externos porque eles não têm uma visão geral dos caminhos de acesso do aplicativo. Consultores normalmente podem considerar uma consulta apenas. Eles não exploram o benefício extra que o índice poderia trazer para outras consultas. Administradores de banco de dados estão em uma posição semelhante como eles podem saber o esquema de banco de dados, mas não têm um conhecimento profundo sobre os caminhos de acesso. 
O único local onde o conhecimento técnico da base de dados atende ao conhecimento funcional do domínio de negócios é o departamento de desenvolvimento. Os desenvolvedores têm uma sensação para os dados e conhecer o caminho de acesso. Eles podem indexar adequadamente para obter o melhor benefício para a aplicação global sem muito esforço. 
Índices Lentos, Parte II 


A seção anterior explicou como obter benefícios adicionais de um índice existente alterando sua ordem de coluna, mas o exemplo considerou apenas duas instruções SQL. Alterar um índice, no entanto, pode afetar todas as consultas na tabela indexada. Esta seção explica como os bancos de dados escolhem um índice e demonstram os possíveis efeitos colaterais ao alterar índices existentes. 
O índice EMPLOYEE_PK adotado melhora o desempenho de todas as consultas que pesquisam somente por subsidiárias. É, no entanto, SUBSIDIARY_ID para todas as SUBSIDIARY_ID pesquisam por SUBSIDIARY_ID independentemente de existirem SUBSIDIARY_ID critérios de pesquisa adicionais. Isso significa que o índice se torna utilizável para consultas que usaram para usar outro índice com outra parte da cláusula where. Nesse caso, se houver vários caminhos de acesso disponíveis, é o trabalho do otimizador escolher o melhor. 
O Query Optimizer 
Alterar um índice também pode ter efeitos colaterais desagradáveis. No nosso exemplo, é o aplicativo de diretório telefônico interno que se tornou muito lento desde a fusão. A primeira análise identificou a seguinte consulta como a causa da desaceleração: 
 SELECT first_name, last_name, subsidiary_id, phone_number FROM employees WHERE last_name = 'WINAND' AND subsidiary_id = 30 
O plano de execução é: 
Exemplo 2.1 Plano de Execução com Índice de Chave Primária Revisado 
 --------------------------------------------------------------- |Id |Operation | Name | Rows | Cost | --------------------------------------------------------------- | 0 |SELECT STATEMENT | | 1 | 30 | |*1 | TABLE ACCESS BY INDEX ROWID| EMPLOYEES | 1 | 30 | |*2 | INDEX RANGE SCAN | EMPLOYEES_PK | 40 | 2 | --------------------------------------------------------------- Predicate Information (identified by operation id): --------------------------------------------------- 1 - filter("LAST_NAME"='WINAND') 2 - access("SUBSIDIARY_ID"=30) 
O plano de execução usa um índice e tem um valor de custo total de 30. Até agora, tão bom. No entanto, é suspeito que ele use o índice que acabamos de mudar - isso é motivo suficiente para suspeitar que a nossa mudança de índice causou o problema de desempenho, especialmente quando se tem em mente a definição do índice antigo - começou com a coluna EMPLOYEE_ID que não faz parte do índice where cláusula em tudo. A consulta não poderia usar esse índice antes. 
Para uma análise mais aprofundada, seria bom comparar o plano de execução antes e depois da alteração. Para obter o plano de execução original, poderíamos simplesmente implementar a definição de índice antiga novamente, porém a maioria dos bancos de dados oferece um método mais simples para evitar o uso de um índice para uma consulta específica. O exemplo a seguir usa uma dica do otimizador Oracle para esse propósito. 
 SELECT /*+ NO_INDEX(EMPLOYEES EMPLOYEE_PK) */ first_name, last_name, subsidiary_id, phone_number FROM employees WHERE last_name = 'WINAND' AND subsidiary_id = 30 
O plano de execução que era presumivelmente usado antes da mudança do índice não usava nenhum índice: 
 ---------------------------------------------------- | Id | Operation | Name | Rows | Cost | ---------------------------------------------------- | 0 | SELECT STATEMENT | | 1 | 477 | |* 1 | TABLE ACCESS FULL | EMPLOYEES | 1 | 477 | ---------------------------------------------------- Predicate Information (identified by operation id): --------------------------------------------------- 1 - filter("LAST_NAME"='WINAND' AND "SUBSIDIARY_ID"=30) 
Mesmo que o TABLE ACCESS FULL deve ler e processar toda a tabela, parece ser mais rápido do que usar o índice neste caso. Isso é particularmente incomum porque a consulta corresponde apenas a uma linha. Usando um índice para encontrar uma única linha deve ser muito mais rápido do que uma varredura completa da tabela, mas neste caso não é. O índice parece ser lento. 
Em tais casos, é melhor passar por cada etapa do plano de execução problemático. O primeiro passo é o INDEX RANGE SCAN no índice EMPLOYEES_PK . Esse índice não cobre a coluna LAST_NAME - o INDEX RANGE SCAN pode SUBSIDIARY_ID apenas o filtro SUBSIDIARY_ID ; O banco de dados Oracle mostra isso no "Predicate Information" entrada de área "2" do plano de execução. Lá você pode ver as condições que são aplicadas para cada operação. 
Dica 
O Apêndice A, " Planos de Execução " , explica como localizar o "Predicate Information" para outros bancos de dados. 
O INDIAN INDEX RANGE SCAN com operação ID 2 ( Exemplo 2.1 ) aplica apenas o filtro SUBSIDIARY_ID=30 . Isso significa que ele atravessa a árvore de índice para SUBSIDIARY_ID a primeira entrada para SUBSIDIARY_ID 30. Em seguida, segue a cadeia de nós folha para SUBSIDIARY_ID todas as outras entradas para essa subsidiária. O ROWIDs do INDEX RANGE SCAN é uma lista de ROWIDs que cumprem a SUBSIDIARY_ID SUBSIDIARY_ID: dependendo do tamanho da filial, pode haver apenas alguns ou pode haver muitas centenas. 
O próximo passo é a operação de TABLE ACCESS BY INDEX ROWID . Ele usa os ROWIDs da etapa anterior para buscar as linhas - todas as colunas - da tabela. Quando a coluna LAST_NAME estiver disponível, o banco de dados poderá avaliar a parte restante da cláusula where. Isso SUBSIDIARY_ID=30 que o banco de dados tem de buscar todas as linhas para SUBSIDIARY_ID=30 antes que ele possa aplicar o filtro LAST_NAME . 
O tempo de resposta da declaração não depende do tamanho do conjunto de resultados, mas do número de funcionários da subsidiária em particular. Se a subsidiária tem apenas alguns membros, o INDEX RANGE SCAN proporciona um melhor desempenho. No entanto, um TABLE ACCESS FULL pode ser mais rápido para uma enorme subsidiária porque ele pode ler grandes partes da tabela de uma só vez (consulte " Full Table Scan " ). 
A consulta é lenta porque a pesquisa de índice retorna muitos ROWIDs - um para cada ROWIDs da empresa original - eo banco de dados deve buscá-los individualmente. É a combinação perfeita dos dois ingredientes que fazem um índice lento: o banco de dados lê um intervalo de índice largo e tem que buscar muitas linhas individualmente. 
Escolher o melhor plano de execução depende da distribuição de dados da tabela, assim também o otimizador usa estatísticas sobre o conteúdo do banco de dados. No nosso exemplo, é utilizado um histograma contendo a distribuição de funcionários sobre subsidiárias. Isso permite que o otimizador estimar o número de linhas retornadas da pesquisa de índice - o resultado é usado para o cálculo do custo. 
Estatísticas 
Se não houver estatísticas disponíveis - por exemplo, porque elas foram excluídas - o otimizador usa valores padrão. As estatísticas padrão do banco de dados Oracle sugerem um pequeno índice com seletividade média. Elas levam à estimativa de que o INDEX RANGE SCAN 40 linhas. O plano de execução mostra essa estimativa na coluna Linhas (novamente, veja Exemplo 2.1 ). Obviamente esta é uma subestimativa grosseira, pois há 1000 funcionários trabalhando para esta subsidiária. 
Se fornecemos estatísticas corretas, o otimizador faz um trabalho melhor. O plano de execução a seguir mostra a nova estimativa: 1.000 linhas para o INDEX RANGE SCAN . Consequentemente, calculou um valor de custo mais elevado para o acesso subsequente à tabela. 
 --------------------------------------------------------------- |Id |Operation | Name | Rows | Cost | --------------------------------------------------------------- | 0 |SELECT STATEMENT | | 1 | 680 | |*1 | TABLE ACCESS BY INDEX ROWID| EMPLOYEES | 1 | 680 | |*2 | INDEX RANGE SCAN | EMPLOYEES_PK | 1000 | 4 | --------------------------------------------------------------- Predicate Information (identified by operation id): --------------------------------------------------- 1 - filter("LAST_NAME"='WINAND') 2 - access("SUBSIDIARY_ID"=30) 
O valor de custo de 680 é ainda mais alto que o valor de custo para o plano de execução usando a EXPLORAÇÃO FULL TABLE SCAN (477). Portanto, o otimizador preferirá automaticamente a varredura de FULL TABLE SCAN . 
Este exemplo de um índice lento não deve ocultar o fato de que a indexação adequada é a melhor solução. É claro que a pesquisa de sobrenome é melhor suportada por um índice em LAST_NAME : 
 CREATE INDEX emp_name ON employees (last_name) 
Usando o novo índice, o otimizador calcula um valor de custo de 3: 
Exemplo 2.2 Plano de Execução com Índice Dedicado 
 -------------------------------------------------------------- | Id | Operation | Name | Rows | Cost | -------------------------------------------------------------- | 0 | SELECT STATEMENT | | 1 | 3 | |* 1 | TABLE ACCESS BY INDEX ROWID| EMPLOYEES | 1 | 3 | |* 2 | INDEX RANGE SCAN | EMP_NAME | 1 | 1 | -------------------------------------------------------------- Predicate Information (identified by operation id): --------------------------------------------------- 1 - filter("SUBSIDIARY_ID"=30) 2 - access("LAST_NAME"='WINAND') 
O acesso ao índice fornece - de acordo com a estimativa do otimizador - apenas uma linha. O banco de dados, portanto, tem que buscar apenas essa linha da tabela: este é definitivamente mais rápido do que uma varredura FULL TABLE SCAN . Um índice devidamente definido ainda é melhor do que a varredura de tabela completa original. 
Os dois planos de execução do Exemplo 2.1 e Exemplo 2.2 são quase idênticos. O banco de dados executa as mesmas operações eo otimizador calculou valores de custo semelhantes, no entanto, o segundo plano funciona muito melhor. A eficiência de um INDIAN INDEX RANGE SCAN pode variar em uma ampla faixa, especialmente quando é seguido por um acesso à tabela. Usar um índice não significa automaticamente que uma instrução seja executada da melhor maneira possível. 
Funções 


O índice de LAST_NAME melhorou consideravelmente o desempenho, mas exige que você procure usando o mesmo caso (superior / inferior) armazenado no banco de dados. Esta seção explica como remover essa restrição sem uma diminuição no desempenho. 
DB2 
MySQL 
Oráculo 
O banco de dados Oracle suporta índices baseados em função desde a versão 8 i . As colunas virtuais foram adicionalmente adicionadas com 11 g . 
PostgreSQL 
servidor SQL 
Se você gosta da minha maneira de explicar as coisas, você vai adorar o meu livro . 
Conteúdo 
1. Busca de maiúsculas e minúsculas - UPPER e LOWER 
2. Funções definidas pelo usuário - Limitações de índices baseados em função 
3. Sobre- Indexação - Evite redundância 
Pesquisa de maiúsculas e minúsculas usando UPPER ou LOWER 


Ignorar o caso em uma cláusula where é muito simples. Você pode, por exemplo, converter ambos os lados da comparação para todas as maiúsculas notação: 
 SELECT first_name, last_name, phone_number FROM employees WHERE UPPER(last_name) = UPPER('winand') 
Independentemente da capitalização usada para o termo de pesquisa ou a coluna LAST_NAME , a função UPPER faz com que eles LAST_NAME como desejado. 
Nota 
Outra maneira de fazer distinção entre maiúsculas e minúsculas é usar um "agrupamento" diferente. As colações padrão usadas pelo SQL Server e MySQL não distinguem entre letras maiúsculas e minúsculas - elas são insensíveis a maiúsculas e minúsculas por padrão. 
A lógica dessa consulta é perfeitamente razoável, mas o plano de execução não é: 
DB2 
Oráculo 
 ---------------------------------------------------- | Id | Operation | Name | Rows | Cost | ---------------------------------------------------- | 0 | SELECT STATEMENT | | 10 | 477 | |* 1 | TABLE ACCESS FULL | EMPLOYEES | 10 | 477 | ---------------------------------------------------- Predicate Information (identified by operation id): --------------------------------------------------- 1 - filter(UPPER("LAST_NAME")='WINAND') 
PostgreSQL 
É um retorno do nosso velho amigo a varredura completa da tabela. Embora haja um índice em LAST_NAME , ele é LAST_NAME porque a pesquisa não está em LAST_NAME mas em UPPER(LAST_NAME) . Do ponto de vista do banco de dados, isso é algo completamente diferente . 
Esta é uma armadilha em que todos podemos cair. Reconhecemos a relação entre LAST_NAME e UPPER(LAST_NAME) instantaneamente e esperamos que o banco de dados "veja" também. Na realidade, a visão do otimizador é mais parecida com isto: 
 SELECT first_name, last_name, phone_number FROM employees WHERE BLACKBOX(...) = 'WINAND' 
A função UPPER é apenas uma caixa preta. Os parâmetros para a função não são relevantes porque não há relação geral entre os parâmetros da função eo resultado. 
Dica 
Substitua o nome da função por BLACKBOX para entender o ponto de vista do otimizador. 
Compilar Avaliação de Tempo 
Para suportar essa consulta, precisamos de um índice que cubra o termo de pesquisa real. Isso LAST_NAME não LAST_NAME um índice em LAST_NAME mas em UPPER(LAST_NAME) : 
 CREATE INDEX emp_up_name ON employees ( UPPER(last_name) ) 
Um índice cuja definição contém funções ou expressões é um chamado índice baseado em função (FBI). Em vez de copiar os dados da coluna diretamente para o índice, um índice baseado em função aplica a função primeiro e coloca o resultado no índice. Como resultado, o índice armazena os nomes em todas as maiúsculas notação. 
O banco de dados pode usar um índice baseado em função se a expressão exata da definição do índice aparecer em uma instrução SQL, como no exemplo acima. O plano de execução confirma isso: 
DB2 
Oráculo 
 -------------------------------------------------------------- |Id |Operation | Name | Rows | Cost | -------------------------------------------------------------- | 0 |SELECT STATEMENT | | 100 | 41 | | 1 | TABLE ACCESS BY INDEX ROWID| EMPLOYEES | 100 | 41 | |*2 | INDEX RANGE SCAN | EMP_UP_NAME | 40 | 1 | -------------------------------------------------------------- Predicate Information (identified by operation id): --------------------------------------------------- 2 - access(UPPER("LAST_NAME")='WINAND') 
PostgreSQL 
É uma varredura regular da escala INDEX RANGE SCAN conforme descrito no Capítulo 1 . O banco de dados atravessa a árvore B e segue a cadeia do nó da folha. Não há operações ou palavras-chave dedicadas para índices baseados em função. 
Atenção 
Às vezes, as ferramentas ORM usam UPPER e LOWER sem o conhecimento do desenvolvedor. O Hibernate, por exemplo, injeta um LOWER implícito para pesquisas que não diferenciam maiúsculas de minúsculas. 
O plano de execução ainda não é o mesmo que estava na seção anterior sem UPPER ; A estimativa de contagem de linha é muito alta. É particularmente estranho que o otimizador espera obter mais linhas da tabela do que o INDEX RANGE SCAN oferece em primeiro lugar. Como ele pode buscar 100 linhas da tabela se a varredura de índice anterior retornou apenas 40 linhas? A resposta é que não pode. Contradicting estimativas como esta muitas vezes indicam problemas com as estatísticas. Neste caso específico, é porque o banco de dados Oracle não atualiza as estatísticas da tabela ao criar um novo índice (consulte também " Estatísticas do Oracle para Índices Baseados em Funções " ). 
Estatísticas do Oracle para Índices Baseados em Funções 
Depois de atualizar as estatísticas, o otimizador calcula estimativas mais precisas: 
Oráculo 
 -------------------------------------------------------------- |Id |Operation | Name | Rows | Cost | -------------------------------------------------------------- | 0 |SELECT STATEMENT | | 1 | 3 | | 1 | TABLE ACCESS BY INDEX ROWID| EMPLOYEES | 1 | 3 | |*2 | INDEX RANGE SCAN | EMP_UP_NAME | 1 | 1 | -------------------------------------------------------------- Predicate Information (identified by operation id): --------------------------------------------------- 2 - access(UPPER("LAST_NAME")='WINAND') 
PostgreSQL 
Nota 
As chamadas "estatísticas estendidas" sobre expressões e grupos de colunas foram introduzidas com o Oracle release 11 g . 
Embora as estatísticas atualizadas não melhorem o desempenho de execução neste caso - o índice foi usado corretamente de qualquer maneira - é sempre uma boa idéia verificar as estimativas do otimizador. O número de linhas processadas para cada operação (estimativa de cardinalidade) é uma figura particularmente importante que também é mostrada nos planos de execução do SQL Server e do PostgreSQL. 
Dica 
O Apêndice A, " Planos de Execução " , descreve as estimativas de contagem de linhas nos planos de execução de outros bancos de dados. 
O SQL Server e o MySQL não suportam índices baseados em função como descrito, mas ambos oferecem uma solução alternativa via colunas computadas ou geradas. Para fazer uso disto, você tem que primeiro adicionar uma coluna computada para a tabela que pode ser indexada depois: 
MySQL 
servidor SQL 
 ALTER TABLE employees ADD last_name_up AS UPPER(last_name) 
 CREATE INDEX emp_up_name ON employees ( last_name_up ) 
SQL Server e MySQL são capazes de usar esse índice sempre que a expressão indexada aparece na instrução. Em alguns casos simples, SQL Server e MySQL podem usar esse índice mesmo se a consulta permanece inalterada. Às vezes, no entanto, a consulta deve alterar a consulta para se referir ao nome das novas colunas para usar o índice. Sempre verifique o plano de execução em caso de dúvida. 
Funções definidas pelo usuário 


A indexação baseada em funções é uma abordagem muito genérica. Além de funções como UPPER você também pode indexar expressões como A + B e até mesmo usar funções definidas pelo usuário na definição do índice. 
Há uma exceção importante. Por exemplo, não é possível referir-se ao tempo atual em uma definição de índice, nem direta nem indiretamente, como no exemplo a seguir. 
 CREATE FUNCTION get_age (date_of_birth DATE) RETURN NUMBER AS BEGIN RETURN TRUNC(MONTHS_BETWEEN(SYSDATE, date_of_birth)/12) ; END 
A função GET_AGE usa a data atual ( SYSDATE ) para calcular a idade com base na data de nascimento fornecida. Você pode usar esta função em todas as partes de uma consulta SQL, por exemplo, em select e as cláusulas where : 
 SELECT first_name, last_name, get_age(date_of_birth) FROM employees WHERE get_age(date_of_birth) = 42 
A consulta lista todos os funcionários de 42 anos. Usar um índice baseado em função é uma idéia óbvia para otimizar essa consulta, mas você não pode usar a função GET_AGE em uma definição de índice porque não é determinística . Isso significa que o resultado da chamada de função não é totalmente determinado por seus parâmetros. Somente as funções que sempre retornam o mesmo resultado para os mesmos parâmetros - funções que são determinísticas - podem ser indexadas. 
A razão por trás dessa limitação é simples. Ao inserir uma nova linha, o banco de dados chama a função e armazena o resultado no índice e ali permanece inalterado. Não há nenhum processo periódico que atualiza o índice. O banco de dados atualiza a idade indexada apenas quando a data de nascimento é alterada por uma instrução de atualização. Após o próximo aniversário, a idade armazenada no índice será errada. 
Além de ser determinista, o PostgreSQL e o banco de dados Oracle exigem que as funções sejam declaradas determinísticas quando usadas em um índice, portanto você precisa usar a palavra-chave DETERMINISTIC (Oracle) ou IMMUTABLE (PostgreSQL). 
Cuidado 
O PostgreSQL eo banco de dados Oracle confiam nas DETERMINISTIC ou IMMUTABLE - isso significa que confiam no desenvolvedor. 
Você pode declarar a função GET_AGE como sendo determinística e usá-la em uma definição de índice. Independentemente da declaração, não funcionará como pretendido porque a idade armazenada no índice não aumentará com o passar dos anos; Os empregados não ficarão mais velhos - pelo menos não no índice. 
Outros exemplos de funções que não podem ser "indexadas" são geradores de números aleatórios e funções que dependem de variáveis ​​de ambiente. 
Nota 
O DB2 não pode usar funções definidas pelo usuário em índices (nem mesmo se elas são determinísticas). 
Dica 
Como você ainda pode usar um índice para otimizar uma consulta para todos os funcionários de 42 anos? 
Sobre-Indexação 


Se o conceito de indexação baseada em função é novo para você, você pode ser tentado a indexar tudo, mas esta é na verdade a última coisa que você deve fazer. A razão é que cada índice causa manutenção contínua. Os índices baseados em função são particularmente problemáticos porque facilitam muito a criação de índices redundantes . 
A pesquisa case-insensitive acima pode ser implementada com a função LOWER também: 
 SELECT first_name, last_name, phone_number FROM employees WHERE LOWER(last_name) = LOWER('winand') 
Um único índice não pode suportar ambos os métodos de ignorar o caso. LOWER(last_name) , é claro, criar um segundo índice em LOWER(last_name) para esta consulta, mas isso LOWER(last_name) que o banco de dados deve manter dois índices para cada instrução insert , update e delete (veja também o Capítulo 8, " Modificando Dados " ). . Para fazer com que um índice seja suficiente, você deve usar consistentemente a mesma função em toda a sua aplicação. 
Dica 
Unificar o caminho de acesso para que um índice possa ser usado por várias consultas. 
Atenção 
Às vezes, as ferramentas ORM usam UPPER e LOWER sem o conhecimento do desenvolvedor. O Hibernate, por exemplo, injeta um LOWER implícito para pesquisas que não diferenciam maiúsculas de minúsculas. 
Dica 
Procure sempre indexar os dados originais, pois isso é muitas vezes a informação mais útil que você pode colocar em um índice. 
Consultas parametrizadas 


Esta seção aborda um tópico ignorado na maioria dos livros de texto SQL: consultas parametrizadas e parâmetros de vinculação. 
Os parâmetros de ligação - também chamados parâmetros dinâmicos ou variáveis ​​de ligação - são uma maneira alternativa de passar dados para o banco de dados. Em vez de colocar os valores diretamente na instrução SQL, basta usar um espaço reservado como ? , :name ou @name e forneça os valores reais usando uma chamada API separada. 
Não há nada de ruim em escrever valores diretamente em declarações ad-hoc; Há, no entanto, duas boas razões para usar parâmetros de ligação em programas: 
Segurança 
Vincular variáveis ​​são a melhor maneira de evitar a injeção SQL . 
atuação 
Bancos de dados com um cache de plano de execução como o SQL Server eo banco de dados Oracle podem reutilizar um plano de execução ao executar a mesma instrução várias vezes. Ele economiza esforço na reconstrução do plano de execução, mas funciona apenas se a instrução SQL for exatamente a mesma. Se você colocar valores diferentes na instrução SQL, o banco de dados manipula-lo como uma instrução diferente e recria o plano de execução. 
Ao usar parâmetros de ligação você não escreve os valores reais, mas sim inserir espaços reservados na instrução SQL. Dessa forma, as declarações não mudam ao executá-las com valores diferentes. 
Naturalmente, há exceções, por exemplo, se o volume de dados afetados depende dos valores reais: 
 SELECT first_name, last_name FROM employees WHERE subsidiary_id = 20 
 --------------------------------------------------------------- |Id | Operation | Name | Rows | Cost | --------------------------------------------------------------- | 0 | SELECT STATEMENT | | 99 | 70 | | 1 | TABLE ACCESS BY INDEX ROWID| EMPLOYEES | 99 | 70 | |*2 | INDEX RANGE SCAN | EMPLOYEE_PK | 99 | 2 | --------------------------------------------------------------- Predicate Information (identified by operation id): --------------------------------------------------- 2 - access("SUBSIDIARY_ID"=20) 
Uma pesquisa de índice oferece o melhor desempenho para pequenas subsidiárias, mas um TABLE ACCESS FULL pode superar o índice para grandes subsidiárias: 
 SELECT first_name, last_name FROM employees WHERE subsidiary_id = 30 
 ---------------------------------------------------- | Id | Operation | Name | Rows | Cost | ---------------------------------------------------- | 0 | SELECT STATEMENT | | 1000 | 478 | |* 1 | TABLE ACCESS FULL | EMPLOYEES | 1000 | 478 | ---------------------------------------------------- Predicate Information (identified by operation id): --------------------------------------------------- 1 - filter("SUBSIDIARY_ID"=30) 
Nesse caso, o histograma em SUBSIDIARY_ID cumpre sua SUBSIDIARY_ID . O otimizador utiliza para determinar a frequência da ID subsidiária mencionado na consulta SQL. Consequentemente, obtém duas estimativas de contagem de linhas diferentes para ambas as consultas. 
O cálculo de custo subsequente resultará, portanto, em dois valores de custo diferentes. Quando o otimizador finalmente seleciona um plano de execução que leva o plano com o valor de custo mais baixo. Para a subsidiária menor, é a que usa o índice. 
O custo da operação de TABLE ACCESS BY INDEX ROWID é altamente sensível à estimativa de contagem de linhas. Selecionar dez vezes mais linhas irá elevar o valor de custo por esse fator. O custo total usando o índice é então ainda maior do que uma varredura de tabela completa. O otimizador, portanto, selecionará o outro plano de execução para a subsidiária maior. 
Ao usar parâmetros de ligação, o otimizador não possui valores concretos disponíveis para determinar sua freqüência. Em seguida, assume apenas uma distribuição igual e sempre obtém as mesmas estimativas de contagem de linhas e valores de custo. No final, ele sempre selecionará o mesmo plano de execução. 
Dica 
Os histogramas de coluna são mais úteis se os valores não forem uniformemente distribuídos. 
Para colunas com distribuição uniforme, é muitas vezes suficiente para dividir o número de valores distintos pelo número de linhas na tabela. Este método também funciona quando se utilizam parâmetros de ligação. 
Se compararmos o otimizador a um compilador, variáveis ​​de vinculação são como variáveis ​​de programa, mas se você escrever os valores diretamente na instrução eles são mais como constantes. O banco de dados pode usar os valores da instrução SQL durante a otimização, assim como um compilador pode avaliar expressões constantes durante a compilação. Os parâmetros de ligação são, simplesmente, não visíveis para o otimizador, assim como os valores de tempo de execução de variáveis ​​não são conhecidos pelo compilador. 
Desta perspectiva, é um pouco paradoxal que os parâmetros de ligação possam melhorar o desempenho se não usar parâmetros de ligação permite que o otimizador opte sempre pelo melhor plano de execução. Mas a questão é a que preço? Gerar e avaliar todas as variantes do plano de execução é um enorme esforço que não vale a pena se você obtiver o mesmo resultado no final de qualquer maneira. 
Dica 
Não usar parâmetros de ligação é como recompilar um programa sempre. 
Decidir construir um plano de execução especializado ou genérico apresenta um dilema para o banco de dados. Qualquer esforço é levado para avaliar todas as possíveis variantes de plano para cada execução para obter sempre o melhor plano de execução ou a sobrecarga de otimização é salva e um plano de execução em cache é usado sempre que possível, aceitando o risco de usar um plano de execução sub-ótimo. O dilema é que o banco de dados não sabe se o ciclo completo de otimização fornece um plano de execução diferente sem realmente fazer a otimização completa. Os fornecedores de banco de dados tentam resolver esse dilema com métodos heurísticos - mas com sucesso muito limitado. 
Como desenvolvedor, você pode usar parâmetros de ligação deliberadamente para ajudar a resolver este dilema. Ou seja, você deve sempre usar parâmetros de ligação, exceto para valores que devem influenciar o plano de execução. 
Códigos de status distribuídos desigualmente como "todo" e "feito" são um bom exemplo. O número de entradas "concluídas" freqüentemente excede os registros de "todo" por uma ordem de magnitude. Usando um índice só faz sentido ao procurar entradas "todo" nesse caso. O particionamento é outro exemplo - isto é, se você dividir tabelas e índices em várias áreas de armazenamento. Os valores reais podem influenciar as partições que devem ser digitalizadas. O desempenho de consultas LIKE pode sofrer de parâmetros de ligação, bem como veremos na próxima seção . 
Dica 
Em toda a realidade, há apenas alguns casos em que os valores reais afetam o plano de execução. Você deve, portanto, usar parâmetros de ligação em caso de dúvida, apenas para evitar injeções SQL. 
Os trechos de código a seguir mostram como usar parâmetros de ligação em várias linguagens de programação. 
C # 
Java 
Sem parâmetros de ligação: 
 int subsidiary_id; Statement command = connection.createStatement( "select first_name, last_name" + " from employees" + " where subsidiary_id = " + subsidiary_id ); 
Usando um parâmetro bind: 
 int subsidiary_id; PreparedStatement command = connection. prepareStatement ( "select first_name, last_name" + " from employees" + " where subsidiary_id = ?" ); command.setInt(1, subsidiary_id); 
Consulte também: PreparedStatement classe PreparedStatement. 
Perl 
PHP 
Rubi 
Veja também 
Exemplos usando Ferramentas ORM 
O ponto de interrogação ( ? ) É o único caractere marcador de posição que o padrão SQL define. Pontos de interrogação são parâmetros posicionais. Isso significa que os pontos de interrogação são numerados da esquerda para a direita. Para vincular um valor a um ponto de interrogação específico, você deve especificar seu número. Isso pode, no entanto, ser muito impraticável porque a numeração muda ao adicionar ou remover espaços reservados. Muitos bancos de dados oferecem uma extensão proprietária para parâmetros nomeados para resolver este problema - por exemplo, usando um símbolo "at" ( @name ) ou dois-pontos ( :name ). 
Nota 
Os parâmetros de ligação não podem alterar a estrutura de uma instrução SQL. 
Isso significa que você não pode usar parâmetros de ligação para nomes de tabela ou coluna. Os seguintes parâmetros de ligação não funcionam: 
 String sql = prepare("SELECT * FROM ? WHERE ?"); sql.execute('employees', 'employee_id = 1'); 
Se você precisar alterar a estrutura de uma instrução SQL durante o tempo de execução, use o SQL dinâmico . 
Procurando por intervalos 


Operadores de desigualdade como < , > e between podem usar índices exatamente como o operador igual explicado acima . Mesmo um filtro LIKE pode - sob certas circunstâncias - usar um índice como as condições de alcance. 
O uso dessas operações limita a escolha da ordem das colunas em índices de várias colunas. Essa limitação pode até mesmo excluir todas as opções de indexação ótimas - existem consultas onde simplesmente não é possível definir uma ordem de coluna "correta". 
Conteúdo 
1. Maior, Menos e BETWEEN - A ordem das colunas revisitada 
2. Indexação SQL LIKE Filters - LIKE não é para pesquisa de texto completo 
3. Index Combine - Por que não usar um índice para cada coluna? 
Maior, Menos e BETWEEN 


O maior risco de desempenho de um INDIAN INDEX RANGE SCAN é o percurso de nó-folha . Portanto, é a regra de ouro da indexação manter o intervalo de índices digitalizados tão pequeno quanto possível. Você pode verificar isso perguntando a si mesmo onde uma varredura de índices começa e onde termina. 
A questão é fácil de responder se a instrução SQL menciona as condições de início e término explicitamente: 
 SELECT first_name, last_name, date_of_birth FROM employees WHERE date_of_birth >= TO_DATE(?, 'YYYY-MM-DD') AND date_of_birth <= TO_DATE(?, 'YYYY-MM-DD') 
Um índice em DATE_OF_BIRTH só é DATE_OF_BIRTH no DATE_OF_BIRTH especificado. A digitalização começa na primeira data e termina na segunda. Não podemos restringir o intervalo de índices digitalizados ainda mais. 
As condições de partida e parada são menos óbvias se uma segunda coluna se torna envolvida: 
 SELECT first_name, last_name, date_of_birth FROM employees WHERE date_of_birth >= TO_DATE(?, 'YYYY-MM-DD') AND date_of_birth <= TO_DATE(?, 'YYYY-MM-DD') AND subsidiary_id = ? 
É claro que um índice ideal tem de cobrir ambas as colunas, mas a questão é em que ordem? 
As figuras a seguir mostram o efeito da ordem das colunas no intervalo de índices varridos. Para esta ilustração buscamos todos os funcionários da subsidiária 27 que nasceram entre 01 de janeiro e 9 de janeiro de 1971. 
A Figura 2.2 visualiza um detalhe do índice em DATE_OF_BIRTH e SUBSIDIARY_ID - nessa ordem. Onde o banco de dados começará a seguir a cadeia do nó da folha, ou para colocá-lo de outra maneira: onde a árvore atravessar final? 

Indexação de filtros LIKE 


O operador SQL LIKE muitas vezes causa um comportamento de desempenho inesperado porque alguns termos de pesquisa evitam o uso eficiente de índices. Isso significa que existem termos de pesquisa que podem ser indexados muito bem, mas outros não. É a posição dos caracteres do comodín que faz toda a diferença. 
O exemplo a seguir usa o % wild card no meio do termo de pesquisa: 
 SELECT first_name, last_name, date_of_birth FROM employees WHERE UPPER(last_name) LIKE 'WIN%D' 
DB2 
MySQL 
Oráculo 
 --------------------------------------------------------------- |Id | Operation | Name | Rows | Cost | --------------------------------------------------------------- | 0 | SELECT STATEMENT | | 1 | 4 | | 1 | TABLE ACCESS BY INDEX ROWID| EMPLOYEES | 1 | 4 | |*2 | INDEX RANGE SCAN | EMP_UP_NAME | 1 | 2 | --------------------------------------------------------------- Predicate Information (identified by operation id): --------------------------------------------------- 2 - access(UPPER("LAST_NAME") LIKE 'WIN%D') filter(UPPER("LAST_NAME") LIKE 'WIN%D') 
PostgreSQL 
LIKE filtros LIKE só podem usar os caracteres antes do primeiro curinga durante o percurso de árvore. Os caracteres restantes são apenas predicados de filtro que não restringem o intervalo de índice digitalizado. Uma única expressão LIKE pode, portanto, conter dois tipos de predicado: (1) a parte antes do primeiro wild card como um predicado de acesso; (2) os outros caracteres como um predicado de filtro. 
Cuidado 
Para o banco de dados PostgreSQL, talvez seja necessário especificar uma classe de operador (por exemplo, varchar_pattern_ops ) para usar expressões LIKE como predicados de acesso. Consulte " Classes Operadoras e Famílias de Operadores" na documentação do PostgreSQL para obter mais detalhes. 
Quanto mais seletivo for o prefixo antes do primeiro caractere curinga, menor será o intervalo do índice pesquisado. Isso, por sua vez, torna a pesquisa de índice mais rápida. A Figura 2.4 ilustra essa relação usando três diferentes expressões LIKE . Todos os três selecionam a mesma linha, mas o intervalo de índice digitalizado - e, portanto, o desempenho - é muito diferente. 
Figura 2.4 Várias LIKE 

A primeira expressão tem dois caracteres antes do wild card. Eles limitam o intervalo de índice digitalizado para 18 linhas. Apenas um deles corresponde a toda a expressão LIKE - os outros 17 são buscados, mas descartados. A segunda expressão tem um prefixo mais longo que restringe o intervalo de índice digitalizado até duas linhas. Com esta expressão, o banco de dados apenas lê uma linha extra que não é relevante para o resultado. A última expressão não tem um predicado de filtro: o banco de dados apenas lê a entrada que corresponde a toda a expressão LIKE . 
Importante 
Somente a parte antes do primeiro wild card serve como um predicado de acesso. 
Os caracteres restantes não restringem o índice de varredura - as entradas não correspondentes são apenas deixadas fora do resultado. 
O caso oposto também é possível: uma expressão LIKE que começa com um wild card. Essa expressão LIKE não pode servir como um predicado de acesso. O banco de dados deve verificar toda a tabela se não houver outras condições que forneçam predicados de acesso. 
Dica 
Evite expressões LIKE com caracteres curinga (por exemplo, '%TERM' ). 
A posição dos caracteres curinga afeta o uso do índice - pelo menos em teoria. Na realidade, o otimizador cria um plano de execução genérico quando o termo de pesquisa é fornecido através de parâmetros de ligação . Nesse caso, o otimizador deve adivinhar se a maioria das execuções terá ou não um wild card principal. 
A maioria dos bancos de dados apenas supor que não existe um wild card principal ao otimizar uma condição LIKE com o parâmetro bind, mas essa suposição é errada se a expressão LIKE for usada para uma pesquisa de texto completo. Não há, infelizmente, nenhuma maneira direta de marcar uma condição LIKE como pesquisa de texto completo. A caixa " rotular Full-Text expressões LIKE " mostra uma tentativa que não funciona. Especificar o termo de pesquisa sem parâmetro de ligação é a solução mais óbvia, mas isso aumenta a sobrecarga de otimização e abre uma vulnerabilidade de injeção de SQL. Uma solução eficaz mas ainda segura e portátil é intencionalmente ofuscar a condição LIKE . " Combinando Colunas " explica isso em detalhes. 
Rotulagem Texto Completo LIKE Expressões 
Para o banco de dados PostgreSQL, o problema é diferente porque o PostgreSQL assume que existe um wild card de destaque ao usar parâmetros bind para uma expressão LIKE . O PostgreSQL simplesmente não usa um índice nesse caso. A única maneira de obter um acesso de índice para uma expressão LIKE é tornar o termo de pesquisa real visível para o otimizador. Se você não usar um parâmetro de ligação, mas colocar o termo de pesquisa diretamente na instrução SQL, você deve tomar outras precauções contra ataques de injeção de SQL! 
Mesmo se o banco de dados otimizar o plano de execução de um wild card principal, ele ainda pode fornecer desempenho insuficiente. Você pode usar outra parte da cláusula where para acessar os dados de forma eficiente nesse caso. Consulte também " Predicados do filtro de índice usados ​​intencionalmente " . Se não houver outro caminho de acesso, você pode usar uma das seguintes soluções de índice de texto completo proprietário. 
DB2 
MySQL 
Oráculo 
O banco de dados Oracle oferece a palavra-chave contains . Consulte o " Guia do desenvolvedor de aplicativos do Oracle Text ". 
PostgreSQL 
servidor SQL 
Pense nisso 
Como indexar uma pesquisa LIKE que tenha apenas um curinga no início do termo de pesquisa ( '%TERM' )? 

Index Merge 

É uma das perguntas mais comuns sobre a indexação: é melhor criar um índice para cada coluna ou um único índice para todas as colunas de uma cláusula where? A resposta é muito simples na maioria dos casos: um índice com várias colunas é melhor - isto é, um índice concatenado ou composto. " Índices Concatenados " explica-os em detalhe . 
No entanto, existem consultas onde um índice único não pode fazer um trabalho perfeito, não importa como você define o índice; Por exemplo, consultas com duas ou mais condições de intervalo independentes, como no exemplo a seguir: 
 SELECT first_name, last_name, date_of_birth FROM employees WHERE UPPER(last_name) < ? AND date_of_birth < ? 
É impossível definir um índice de árvore B que suporte esta consulta sem predicados de filtro. Para obter uma explicação, basta lembrar que um índice é uma lista vinculada. 
Se você definir o índice como UPPER(LAST_NAME) , DATE_OF_BIRTH (nessa ordem), a lista começa com A e termina com Z. A data de nascimento é considerada somente quando há dois funcionários com o mesmo nome. Se você definir o índice ao contrário, ele começará com os funcionários mais antigos e terminará com o mais novo. Nesse caso, os nomes só têm um impacto menor na ordem de classificação. 
Não importa como você torce e gire a definição do índice, as entradas são sempre dispostas ao longo de uma cadeia. Em uma extremidade, você tem as entradas pequenas e na outra extremidade as grandes. Portanto, um índice só pode suportar uma condição de intervalo como um predicado de acesso. Suportando duas condições de intervalo independentes requer um segundo eixo, por exemplo, como um tabuleiro de xadrez. A consulta acima corresponderia a todas as entradas de um canto do tabuleiro de xadrez, mas um índice não é como um tabuleiro de xadrez - é como uma cadeia. Não há canto. 
É claro que você pode aceitar o predicado do filtro e usar um índice de várias colunas. Essa é a melhor solução em muitos casos de qualquer maneira. A definição do índice deve então mencionar a coluna mais seletiva primeiro para que ela possa ser usada com um predicado de acesso. Essa pode ser a origem do mito " mais seletivo primeiro ", mas essa regra só é válida se você não puder evitar um predicado de filtro. 
A outra opção é usar dois índices separados, um para cada coluna. Em seguida, o banco de dados deve digitalizar os dois índices primeiro e, em seguida, combinar os resultados. A pesquisa de índice duplicado sozinha já envolve mais esforço porque o banco de dados tem de percorrer duas árvores de índice. Além disso, o banco de dados precisa de muita memória e tempo de CPU para combinar os resultados intermediários. 
nota 
Um índice de digitalização é mais rápido do que dois. 
Bases de dados utilizam dois métodos para combinar índices. Em primeiro lugar, há a junção de índice. Capítulo 4 " A Operação de Junção " explica os algoritmos relacionados em detalhe. A segunda abordagem faz uso da funcionalidade do mundo do data warehouse. 
O data warehouse é a matriz de todas as consultas ad-hoc. Ele só precisa de alguns cliques para combinar condições arbitrárias na consulta de sua escolha. É impossível prever as combinações de colunas que podem aparecer na cláusula where e que torna a indexação, como explicado até agora, quase impossível. 
Os data warehouses usam um tipo de índice de propósito especial para resolver esse problema: o chamado índice de bitmap. A vantagem dos índices de bitmap é que eles podem ser combinados com bastante facilidade. Isso significa que você obtém desempenho decente ao indexar cada coluna individualmente. Por outro lado, se você souber a consulta com antecedência, para que você possa criar um personalizado multi-coluna B-árvore índice, ainda será mais rápido do que combinar vários índices de bitmap. 
De longe, a maior fraqueza dos índices de bitmap é a incrível insert , atualização e delete escalabilidade. Operações de escrita simultâneas são praticamente impossíveis. Isso não é problema em um data warehouse porque os processos de carga são agendados um após o outro. Nos aplicativos on-line, os índices de bitmap são em sua maioria inúteis. 
Importante 
Os índices de bitmap são quase inutilizáveis ​​para o processamento de transações on-line (OLTP). 
Muitos produtos de banco de dados oferecem uma solução híbrida entre índices de árvore B e bitmap. Na ausência de um caminho de acesso melhor, eles convertem os resultados de várias varreduras de árvore B em estruturas de bitmap em memória. Aqueles podem ser combinados de forma eficiente. As estruturas de bitmap não são armazenadas persistentemente mas descartadas após a execução da instrução, ignorando assim o problema da escalabilidade de escrita deficiente. A desvantagem é que ele precisa de muita memória e tempo de CPU. Este método é, afinal, um ato de otimizador de desespero. 

Índices parciais 


Até agora, apenas discutimos quais colunas adicionar a um índice. Com índices parciais (PostgreSQL) ou filtrados (SQL Server), você também pode especificar as linhas indexadas. 
Cuidado 
O banco de dados Oracle tem uma abordagem exclusiva para a indexação parcial. A próxima seção explica isso enquanto se baseia nesta seção. 
O DB2 não suporta índices parciais, mas pode ser emulado como no banco de dados Oracle ao usar o recurso EXCLUDE NULL KEYS . 
Um índice parcial é útil para comumente usado where condições que usam valores constantes - como o código de status no exemplo a seguir: 
 SELECT message FROM messages WHERE processed = 'N' AND receiver = ? 
Consultas como essa são muito comuns em sistemas de filas. A consulta obtém todas as mensagens não processadas para um destinatário específico. Mensagens que já foram processadas raramente são necessárias. Se eles são necessários, eles geralmente são acessados ​​por um critério mais específico, como a chave primária. 
Podemos otimizar esta consulta com um índice de duas colunas. Considerando apenas esta consulta, a ordem das colunas não importa porque não há nenhuma condição de intervalo. 
 CREATE INDEX messages_todo ON messages (receiver, processed) 
O índice cumpre sua finalidade, mas inclui muitas linhas que nunca são pesquisadas, ou seja, todas as mensagens que já foram processadas. Devido à escalabilidade logarítmica o índice, no entanto, torna a consulta muito rápida, embora desperdiça muito espaço em disco. 
Com a indexação parcial, você pode limitar o índice para incluir apenas as mensagens não processadas. A sintaxe para isso é surpreendentemente simples: uma cláusula where. 
 CREATE INDEX messages_todo ON messages (receiver) WHERE processed = 'N' 
O índice contém apenas as linhas que satisfazem a cláusula where. Neste caso particular, podemos até mesmo remover a coluna PROCESSED porque é sempre 'N' qualquer maneira. Isso significa que o índice reduz seu tamanho em duas dimensões: verticalmente, porque contém menos linhas; Horizontalmente, devido à coluna removida. 
O índice é, portanto, muito pequeno. Para uma fila, pode até significar que o tamanho do índice permanece inalterado, embora a tabela cresça sem limites. O índice não contém todas as mensagens, apenas as não processadas. 
A cláusula where de um índice parcial pode se tornar arbitrariamente complexa. A única limitação fundamental é sobre funções: você só pode usar funções determinísticas como é o caso em toda parte em uma definição de índice. No entanto, o SQL Server tem regras mais restritivas e não permite funções nem o operador OR em predicados de índice . 
Um banco de dados pode usar um índice parcial sempre que a cláusula where aparece em uma consulta. 
Pense nisso 
Que peculiaridade tem o menor índice possível para a seguinte consulta: 
 SELECT message FROM messages WHERE processed = 'N' 

NULL no banco de dados Oracle 

SQL NULL freqüentemente provoca confusão. Embora a idéia básica de NULL - para representar dados em falta - é bastante simples, existem algumas peculiaridades. Você tem que usar IS NULL em vez de = NULL , por exemplo. Além disso, o banco de dados Oracle tem esquisitices NULL adicionais, por um lado, porque nem sempre lidar com NULL como exigido pelo padrão e por outro lado porque tem um tratamento muito "especial" de NULL em índices. 
O padrão SQL não define NULL como um valor, mas sim como um espaço reservado para um valor ausente ou desconhecido. Conseqüentemente, nenhum valor pode ser NULL . Em vez disso, o banco de dados Oracle trata uma seqüência vazia como NULL : 
  SELECT '0 IS NULL???' AS "what is NULL?" FROM dual WHERE 0 IS NULL UNION ALL SELECT '0 is not null' FROM dual WHERE 0 IS NOT NULL UNION ALL  SELECT ''''' IS NULL???' FROM dual WHERE '' IS NULL UNION ALL SELECT ''''' is not null' FROM dual WHERE '' IS NOT NULL 
 what is NULL? -------------- 0 is not null '' IS NULL??? 
Para adicionar à confusão, há mesmo um caso quando o banco de dados Oracle trata NULL como seqüência vazia: 
 SELECT dummy , dummy || '' , dummy || NULL FROM dual 
 DDD - - - XXX 
Concatenar a coluna DUMMY (sempre contendo 'X' ) com NULL deve retornar NULL . 
O conceito de NULL é usado em muitas linguagens de programação. Não importa onde você olhe, uma seqüência de caracteres vazia nunca é NULL ... exceto no banco de dados Oracle. É, de facto, impossível armazenar uma cadeia vazia num campo VARCHAR2 . Se você tentar, o banco de dados Oracle apenas armazena NULL . 
Esta peculiaridade não é apenas estranha; Também é perigoso. Além disso, a estranheza NULL do banco de dados Oracle não pára aqui - ela continua com a indexação. 
Se você gosta da minha maneira de explicar as coisas, você vai adorar o meu livro . 
conteúdo 
1. NULL em Índices - Cada índice é um índice parcial 
2. NOT NULL Restrições - afeta o uso do índice 
3. Emulação de índices parciais - usando a indexação baseada em função 

Condições Ofuscadas 


As seções a seguir demonstram alguns métodos populares para condições de ofuscação. Condições ofuscadas são where cláusulas que são formuladas de uma forma que impede o uso de índice apropriado. Esta seção é uma coleção de anti-padrões que cada desenvolvedor deve conhecer e evitar. 
conteúdo 
1. Datas - Preste atenção especial aos tipos DATE 
2. Cordas Numéricas - Não misture tipos 
3. Combinando Colunas - use redundante where cláusulas 
4. Smart Logic - A maneira mais inteligente de fazer o SQL lento 
5. Matemática - Bases de dados não resolvem equações 

Tipos de datas 


A maioria das ofuscações envolvem tipos DATE . O banco de dados Oracle é particularmente vulnerável a este respeito, porque ele tem apenas um tipo DATE que sempre inclui um componente de tempo também. 
Tornou-se prática comum usar a função TRUNC para remover o componente de tempo. Na verdade, ele não remove o tempo, mas, em vez disso, define-lo à meia-noite porque o banco de dados Oracle não tem tipo DATE puro. Para ignorar o componente de tempo para uma pesquisa, você pode usar a função TRUNC em ambos os lados da comparação, por exemplo, para procurar as vendas de ontem: 
 SELECT ... FROM sales WHERE TRUNC(sale_date) = TRUNC(sysdate - INTERVAL '1' DAY) 
É uma declaração perfeitamente válida e correta, mas não pode usar SALE_DATE um índice em SALE_DATE . É como explicado em " Case-Insensitive Search usando UPPER ou LOWER " ; TRUNC(sale_date) é algo inteiramente diferente de SALE_DATE funções são caixas negras para o banco de dados. 
Há uma solução bastante simples para esse problema: um índice baseado em função . 
 CREATE INDEX index_name ON sales ( TRUNC(sale_date) ) 
Mas então você deve sempre usar TRUNC(sale_date) na cláusula where. Se você usá-lo de forma inconsistente, às vezes com, às vezes sem TRUNC , então você precisa de dois índices! 
O problema também ocorre com bancos de dados que têm um tipo de data pura se você procurar por um período mais longo como mostrado na seguinte consulta MySQL: 
 SELECT ... FROM sales WHERE DATE_FORMAT(sale_date, "%Y-%M") = DATE_FORMAT(now() , "%Y-%M") 
A consulta usa um formato de data que contém apenas ano e mês: novamente, esta é uma consulta absolutamente correta que tem o mesmo problema como antes. No entanto, a solução acima não se aplica ao MySQL anterior à versão 5.7, porque o MySQL não suporta indexação baseada em função antes dessa versão. 
A alternativa é usar uma condição de intervalo explícito. Esta é uma solução genérica que funciona para todos os bancos de dados: 
 SELECT ... FROM sales WHERE sale_date BETWEEN quarter_begin(?) AND quarter_end(?) 
Se você tiver feito sua lição de casa, você provavelmente reconhece o padrão do exercício sobre todos os funcionários que são 42 anos de idade . 
Um índice reto em SALE_DATE é SALE_DATE para otimizar esta consulta. As funções QUARTER_BEGIN e QUARTER_END calculam as datas limite. O cálculo pode se tornar um pouco complexo porque o operador between sempre inclui os valores de limite . A função QUARTER_END deve, portanto, devolver um carimbo de hora antes do primeiro dia do próximo SALE_DATE se o SALE_DATE tiver um componente de hora. Essa lógica pode ser oculta na função. 
Os exemplos a seguir mostram implementações das funções QUARTER_BEGIN e QUARTER_END para vários bancos de dados. 
DB2 
MySQL 
Oráculo 
 CREATE FUNCTION quarter_begin(dt IN DATE) RETURN DATE AS BEGIN RETURN TRUNC(dt, 'Q'); END 
 CREATE FUNCTION quarter_end(dt IN DATE) RETURN DATE AS BEGIN -- the Oracle DATE type has seconds resolution -- subtract one second from the first -- day of the following quarter RETURN TRUNC(ADD_MONTHS(dt, +3), 'Q') - (1/(24*60*60)); END 
PostgreSQL 
servidor SQL 
Você pode usar funções auxiliares semelhantes para outros períodos - a maioria deles será menos complexa do que os exemplos acima, especialmente quando se usa maior ou igual a ( >= ) e menor que ( < ) condições em vez do operador between . Claro que você poderia calcular as datas limite em seu aplicativo se você desejar. 
Dica 
Escreva consultas para períodos contínuos como condição de intervalo explícito. Faça isso mesmo por um único dia - por exemplo, para o banco de dados Oracle: 
  sale_date >= TRUNC(sysdate) AND sale_date < TRUNC(sysdate + INTERVAL '1' DAY) 
Outra ofuscação comum é comparar datas como seqüências de caracteres como mostrado no seguinte exemplo do PostgreSQL: 
 SELECT ... FROM sales WHERE TO_CHAR(sale_date, 'YYYY-MM-DD') = '1970-01-01' 
O problema é, novamente, converter SALE_DATE . Essas condições são muitas vezes criadas na crença de que você não pode passar tipos diferentes de números e cadeias de caracteres para o banco de dados. Os parâmetros de ligação , no entanto, suportam todos os tipos de dados. Isso java.util.Date que você pode, por exemplo, usar um objeto java.util.Date como parâmetro de ligação. Este é mais um benefício dos parâmetros bind. 
Se você não pode fazer isso, basta converter o termo de pesquisa em vez da coluna da tabela: 
 SELECT ... FROM sales WHERE sale_date = TO_DATE('1970-01-01', 'YYYY-MM-DD') 
Esta consulta pode usar um índice direto em SALE_DATE . Além disso, converte a cadeia de entrada apenas uma vez. A instrução anterior deve converter todas as datas armazenadas na tabela antes de poder compará-las com o termo de pesquisa. 
Qualquer mudança que você fizer - usando um parâmetro de ligação ou convertendo o outro lado da comparação - você pode facilmente introduzir um bug se SALE_DATE tiver um componente de tempo. Você deve usar uma condição de intervalo explícito nesse caso: 
 SELECT ... FROM sales WHERE sale_date >= TO_DATE('1970-01-01', 'YYYY-MM-DD') AND sale_date < TO_DATE('1970-01-01', 'YYYY-MM-DD') + INTERVAL '1' DAY 
Sempre considere usar uma condição de intervalo explícito ao comparar datas. 
